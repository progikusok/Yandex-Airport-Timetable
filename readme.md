<h1>Табло рейсов</h1>

<p><img src="app/img/preview.jpg" alt="preview"></p>

<p><strong>Табло рейсов</strong> — реализация тестового задания от Яндекса в качестве испытания на стажировку. В табло должны быть реализованы следующие функции:</p>

<ul>
  <li>Просмотр только вылетающих рейсов</li>
  <li>Просмотр только прилетающих рейсов</li>
  <li>Просмотр задержанных рейсов</li>
  <li>Поиск по номеру рейса</li>
</ul>

<h2>Установка и запуск</h2>

    npm i
    gulp

<h2>Используемые библиотеки</h2>

<p>В тестовом задании было указано, что <q>ограничений на использование шаблонизаторов и библиотек нет</q>. Поэтому я решил использовать следующие библиотеки, которые мне показались наиболее удобными</p>

<ul>
  <li><strong>JQuery</strong> – для динамики работы с веб-приложением;</li>
  <li><strong>Vue.js</strong> – для рекативной отрисовки данных;</li>
  <li><strong>Bootstrap 4</strong> – для адаптивной верстки</li>
</ul>

    app/lib

<h2>Реализация</h2>

<p>В условии задания было сказано, что использование публичных api будет плюсом. Поэтому я и начал разработку с поиска подходящих.
  Нашел наиболее подходящие здесь – http://aviation-edge.com/. Но пока отлаживал проект, растратил лимит обращений.
  Ценным данный ресурс был из-за того, что там была информация о задержанных рейсах, которые отобразить требуется по заданию. Далее,
  ресурс попросил меня оплатить подписку, а создать другой аккаунт – запретил.
</p>

<p>Второй подходящий ресурс – https://api.flightstats.com/. Он в итоге и вошел в конечную сборку. Здесь нет информации о задержанных рейсах.
  Но эти данные имеют ряд преимуществ. Например, для него проще создается фильтрация, которая соотвествет запросу из поиска. Также данные предоставляются по дате и конкретному часу.
</p>

<p>Другими словами, реализации <i>задеражнных рейсов</i> у меня нет как таковой, потому что нет данных с api для отображения. Но по готовой верстке
  Вы можете заметить, что функционал для данной реализации <i>задеражнных рейсов</i> я подготовил. То есть, если добавить данные в api, то реализация будет готова.
</p>

<h3>Компенсация</h3>

<p>Я решил добавить функционала. В данном клиентском приложении можно выбрать данные по конкретной дате и по часу. По умолчанию устанавливается текущая дата и время.
  Мне остается только надеяться, что это сгладит "невыполненный пункт", потому что других api мне найти не удалось, а создавать свой файл для реализации этих нужд совсем не хотелось,
  после того, как получилась реализация с публичным api.
</p>

<h3>Иформация по городам</h3>

<p>В api нет данных по городу, откуда рейс. Есть только коды аэропорта согласно спецификации iata. Чтобы максимально стремиться к референсу из задания – 
  [https://www.svo.aero](https://www.svo.aero/ru/timetable/departure?date=today&period=16:00-18:00&terminal=all) – хотелось бы все-таки добиться отображения читабельных названий.
  Для этих нужд я скачал файл соотвествия кодов аэропортов с названиями. Это файл <code>cases.json</code>, с ним идет необходимая фильтрация названий с помощью возможностей vue.
</p>

<h3>Мобильная версия</h3>

<p>Данной реализации соотвествует полностью адаптивный интерфейс благодаря <code>Bootstrap 4</code></p>

<h1>Дополнительное задание</h1>

<p>Почему <code>this._i</code> не увеличивается. Как исправить?</p>

```javascript
function Ticker() {
  this._i = 0
};

Ticker.prototype = {
  tick: function() {
     console.log(this._i++);
  }
};

var ticker = new Ticker();
setInterval(ticker.tick, 1000);
```
<h3>Ответ</h3>

<p>Причина некорректной работы кода кроется внутри функции <code>setInterval(...)</code>.
Код внутри этой функции выполняется в отдельной области видимости, а значит значение <code>this</code> будет равно глобальной области видимости, т.е. <code>window</code> (<code>this = window</code>).
Глобальный объект <code>window</code>, в свою очередь, не имеет значение <code>_i</code>. То есть при выполнении получаем <code>undefined + 1 = NaN</code>, что и приводит к некорректной работе.
</p>

<h3>Варианты исправления</h3>

<h4>Вариант 1</h4>

<p>Надо передать контекст исполнения, а точнее привязать. Тогда мы явно указываем в какой области видимости должен выполняться код. Делаем это при помощи <code>bind</code>.</p>

```javascript
function Ticker() {
  this._i = 0
};

Ticker.prototype = {
  tick: function() {
     console.log(this._i++);
  }
};

var ticker = new Ticker();
setInterval(ticker.tick.bind(this), 1000);
```

<h4>Вариант 2</h4>

<p>Смысл такой же как с <code>bind</code>. Нужно передать контекст исполнения. Поэтому в области видимости <code>window</code> создадим элемент <code>self</code>, куда и сохраним необходимый <code>this</code>.
Если верить интернету и учебникам, это самый кроссбраузерный способ.
</p>

```javascript
var self = null;

function Ticker() {
    this._i = 0;
    self = this;
};

Ticker.prototype = {
  tick: function() {
     console.log(self._i++);
  }
};

var ticker = new Ticker();
setInterval(ticker.tick, 1000);
```
<h4>Вариант 3</h4>
<p>Не рекоммендуется применять согласно слогану <q>eval is evil</q> (потому что <code>eval</code> имеет доступ к локальным переменным, которые легко могут быть переименованы, а значит код будет не валидным). Но здесь приводим в качестве примера.</p>

```javascript
var self = null;

function Ticker() {
    this._i = 0;
    self = this;
};

Ticker.prototype = {
  tick: function() {
     console.log(self._i++);
  }
};

var ticker = new Ticker();
setInterval(eval('ticker.tick'), 1000);
```
